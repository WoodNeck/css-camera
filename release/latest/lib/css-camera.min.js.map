{"version":3,"file":"css-camera.min.js","sources":["../src/utils/helper.ts","../src/constants/error.ts","../src/utils/math.ts","../src/constants/default.ts","../src/CSSCamera.ts"],"sourcesContent":["import { mat4, vec3 } from 'gl-matrix';\nimport { ELEMENT_NOT_EXIST, MUST_STRING_OR_ELEMENT } from '../constants/error';\nimport { Matrix4x4, Offset } from '../types';\n\nexport const getElement = (el: string | HTMLElement, baseElement?: HTMLElement): HTMLElement => {\n    if (typeof el === 'string') {\n        const queryResult = baseElement\n          ? baseElement.querySelector(el)\n          : document.querySelector(el);\n        if (!queryResult) {\n            throw new Error(ELEMENT_NOT_EXIST(el));\n        }\n        return queryResult as HTMLElement;\n    } else if (el.nodeName && el.nodeType === 1) {\n        return el;\n    } else {\n        throw new Error(MUST_STRING_OR_ELEMENT(el));\n    }\n};\n\nexport function applyCSS(element: HTMLElement, cssObj: { [keys: string]: string }): void {\n  Object.keys(cssObj).forEach(property => {\n    (element.style as any)[property] = cssObj[property];\n  });\n}\n\nexport function getTransformMatrix(elStyle: CSSStyleDeclaration): mat4 {\n  const trVal = elStyle.getPropertyValue('transform');\n  const transformStr = /\\(((\\s|\\S)+)\\)/.exec(trVal);\n  const matrixVal = transformStr\n    ? transformStr[1].split(',').map(val => parseFloat(val)) as Matrix4x4\n    : [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] as Matrix4x4;\n  if (matrixVal.length === 16 ) {\n    return mat4.fromValues(...matrixVal);\n  } else {\n    // Convert 2d matrix(length 6) to 3d\n    const matrix = mat4.create();\n    mat4.identity(matrix);\n\n    matrix[0] = matrixVal[0];\n    matrix[1] = matrixVal[1];\n    matrix[4] = matrixVal[2];\n    matrix[5] = matrixVal[3];\n    matrix[12] = matrixVal[4];\n    matrix[13] = matrixVal[5];\n\n    return matrix;\n  }\n}\n\nexport function getOffsetFromParent(currentOffset: Offset, parentOffset: Offset): vec3 {\n  const offsetLeft = currentOffset.left + (currentOffset.width - parentOffset.width) / 2;\n  const offsetTop = currentOffset.top + (currentOffset.height - parentOffset.height) / 2;\n\n  return vec3.fromValues(offsetLeft, offsetTop, 0);\n}\n\nexport function getRotateOffset(elStyle: CSSStyleDeclaration, currentOffset: Offset): vec3 {\n  const axis = (elStyle.transformOrigin as string)\n    .split(' ')\n    .map(str => parseFloat(str.substring(0, str.length - 2)));\n  const ax = axis[0] - currentOffset.width / 2;\n  const ay = axis[1] - currentOffset.height / 2;\n\n  return vec3.fromValues(ax, ay, 0);\n}\n\nexport function findIndex<T>(iterable: T[], callback: (el: T) => boolean): number {\n  for (let i = 0; i < iterable.length; i += 1) {\n    const element = iterable[i];\n    if (element && callback(element)) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\n// return [0, 1, ...., max - 1]\nexport function range(max: number): number[] {\n  const counterArray: number[] = [];\n  for (let i = 0; i < max; i += 1) {\n    counterArray[i] = i;\n  }\n  return counterArray;\n}\n\nexport function clamp(val: number, min: number, max: number): number {\n  return Math.max(Math.min(val, max), min);\n}\n","export const ELEMENT_NOT_EXIST = (selector: string) => `Element with selector \"${selector}\" doesn't exist.`;\nexport const MUST_STRING_OR_ELEMENT = (received: any) => `Element should be provided in string or HTMLElement. Received: ${received}`;\n","import { mat4, quat, vec3 } from 'gl-matrix';\nimport { clamp } from './helper';\n\nexport function degToRad(deg: number): number {\n  return Math.PI * deg / 180;\n}\n\nexport function radToDeg(rad: number): number {\n  return 180 * rad / Math.PI;\n}\n\n// From Three.js https://github.com/mrdoob/three.js/blob/dev/src/math/Euler.js\nexport function quatToEuler(q: quat): vec3 {\n  const rotM = mat4.create();\n  mat4.fromQuat(rotM, q);\n\n  const m11 = rotM[0];\n  const m12 = rotM[4];\n  // const m13 = rotM[8];\n  const m21 = rotM[1];\n  const m22 = rotM[5];\n  // const m23 = rotM[9];\n  const m31 = rotM[2];\n  const m32 = rotM[6];\n  const m33 = rotM[10];\n\n  const euler = vec3.create();\n\n  // ZYX\n  euler[1] = Math.asin(-clamp(m31, -1, 1));\n  if (Math.abs(m31) < 0.99999) {\n    euler[0] = Math.atan2(m32, m33);\n    euler[2] = Math.atan2(m21, m11);\n  } else {\n    euler[0] = 0;\n    euler[2] = Math.atan2(-m12, m22);\n  }\n\n  return euler.map(val => radToDeg(val)) as vec3;\n}\n","export default {\n  FOV: 50,\n  ORTHOGRAPHIC: false,\n  STYLE: {\n    VIEWPORT: {\n      width: '100%',\n      height: '100%',\n      'transform-style': 'preserve-3d',\n      overflow: 'hidden',\n    },\n    CAMERA: {\n      width: '100%',\n      height: '100%',\n      'transform-style': 'preserve-3d',\n      'will-change': 'transform',\n    },\n    WORLD: {\n      width: '100%',\n      height: '100%',\n      'transform-style': 'preserve-3d',\n      'will-change': 'transform',\n    },\n  },\n  CLASS: {\n    VIEWPORT: 'cc-viewport',\n    CAMERA: 'cc-camera',\n    WORLD: 'cc-world',\n  },\n};\n","import { mat4, vec3, quat } from 'gl-matrix';\nimport { getElement, applyCSS, getTransformMatrix, findIndex, getOffsetFromParent, getRotateOffset } from './utils/helper';\nimport { quatToEuler } from './utils/math';\nimport DEFAULT from './constants/default';\nimport { Offset, UpdateOption, ValueOf } from './types';\n\nclass CSSCamera {\n  private _element: HTMLElement;\n  private _viewportEl: HTMLElement;\n  private _cameraEl: HTMLElement;\n  private _worldEl: HTMLElement;\n\n  private _position: vec3;\n  private _scale: vec3;\n  private _rotation: vec3;\n  private _perspective: number;\n  private _perspectiveOffset: number;\n  private _updateTimer: number;\n\n  /**\n   * Current version of CSSCamera.\n   * @example\n   * console.log(CSSCamera.VERSION); // ex) 1.0.0\n   * @type {string}\n   */\n  static get VERSION() { return '#__VERSION__#'; }\n\n  /**\n   * The element provided in the constructor.\n   * @example\n   * const camera = new CSSCamera(el);\n   * console.log(camera.element === el); // true\n   * @type {HTMLElement}\n   */\n  public get element() { return this._element; }\n\n  /**\n   * The reference of viewport DOM element.\n   * @type {HTMLElement}\n   */\n  public get viewportEl() { return this._viewportEl; }\n\n  /**\n   * The reference of camera DOM element.\n   * @type {HTMLElement}\n   */\n  public get cameraEl() { return this._cameraEl; }\n\n  /**\n   * The reference of world DOM element.\n   * @type {HTMLElement}\n   */\n  public get worldEl() { return this._worldEl; }\n\n  /**\n   * The current position as number array([x, y, z]).\n   * @example\n   * const camera = new CSSCamera(el);\n   * console.log(camera.position); // [0, 0, 0];\n   * camera.position = [0, 0, 300];\n   * console.log(camera.position); // [0, 0, 300];\n   * @type {number[]}\n   */\n  public get position() { return [...this._position]; }\n\n  /**\n   * The current scale as number array([x, y, z]).\n   * @example\n   * const camera = new CSSCamera(el);\n   * console.log(camera.scale); // [1, 1, 1];\n   * camera.scale = [5, 1, 1];\n   * console.log(camera.scale); // [5, 1, 1];\n   * @type {number[]}\n   */\n  public get scale() { return [...this._scale]; }\n\n  /**\n   * The current euler rotation as number array([x, y, z]).\n   * @example\n   * const camera = new CSSCamera(el);\n   * console.log(camera.rotation); // [0, 0, 0];\n   * camera.rotation = [90, 0, 0];\n   * console.log(camera.rotation); // [90, 0, 0];\n   * @type {number[]}\n   */\n  public get rotation() { return [...this._rotation]; }\n\n  /**\n   * The current quaternion rotation as number array([x, y, z, w]).\n   * @example\n   * const camera = new CSSCamera(el);\n   * console.log(camera.quaternion); // [0, 0, 0, 1];\n   * camera.rotation = [90, 0, 0];\n   * console.log(camera.quaternion); // [0.7071067690849304, 0, 0, 0.7071067690849304];\n   * camera.quaternion = [0, 0, 0, 1];\n   * console.log(camera.rotation); // [0, -0, 0];\n   * @type {number[]}\n   */\n  public get quaternion() {\n    const r = this._rotation;\n    const quaternion = quat.fromEuler(quat.create(), r[0], r[1], r[2]);\n\n    return [...quaternion];\n  }\n\n  /**\n   * The current perspective value that will be applied to viewport element.\n   * @example\n   * const camera = new CSSCamera(el);\n   * camera.perspective = 300;\n   * console.log(camera.perspective); // 300\n   * @type {number}\n   */\n  public get perspective() { return this._perspective; }\n\n  /**\n   * The current perspective offset value that will be applied to camera element.\n   * @example\n   * const camera = new CSSCamera(el);\n   * camera.perspective = 300;\n   * console.log(camera.cameraCSS); // scale3d(1, 1, 1) translateZ(300px) rotateX(0deg) rotateY(0deg) rotateZ(0deg);\n   * camera.perspectiveOffset = 100;\n   * console.log(camera.cameraCSS); // scale3d(1, 1, 1) translateZ(400px) rotateX(0deg) rotateY(0deg) rotateZ(0deg);\n   * @type {number}\n   */\n  public get perspectiveOffset() { return this._perspectiveOffset; }\n\n  /**\n   * CSS string can be applied to camera element based on current transform.\n   * @example\n   * const camera = new CSSCamera(el);\n   * camera.perspective = 300;\n   * console.log(camera.cameraCSS); // scale3d(1, 1, 1) translateZ(300px) rotateX(0deg) rotateY(0deg) rotateZ(0deg);\n   * @type {string}\n   */\n  public get cameraCSS() {\n    const perspective = this._perspective;\n    const perspectiveOffset = this._perspectiveOffset;\n    const rotation = this._rotation;\n    const scale = this._scale;\n\n    // Rotate in order of Z - Y - X\n    // tslint:disable-next-line: max-line-length\n    return `scale3d(${scale[0]}, ${scale[1]}, ${scale[2]}) translateZ(${perspective + perspectiveOffset}px) rotateX(${rotation[0]}deg) rotateY(${rotation[1]}deg) rotateZ(${rotation[2]}deg)`;\n  }\n\n  /**\n   * CSS string can be applied to world element based on current transform.\n   * ```\n   * const camera = new CSSCamera(el);\n   * console.log(camera.worldCSS); // \"translate3d(0px, 0px, 0px)\";\n   * camera.translate(0, 0, 300);\n   * console.log(camera.worldCSS); // \"translate3d(0px, 0px, -300px)\";\n   * ```\n   * @type {string}\n   */\n  public get worldCSS() {\n    const position = this._position;\n\n    return `translate3d(${-position[0]}px, ${-position[1]}px, ${-position[2]}px)`;\n  }\n\n  public set position(val: number[]) { this._position = vec3.fromValues(val[0], val[1], val[2]); }\n  public set scale(val: number[]) { this._scale = vec3.fromValues(val[0], val[1], val[2]); }\n  public set rotation(val: number[]) { this._rotation = vec3.fromValues(val[0], val[1], val[2]); }\n  public set quaternion(val: number[]) { this._rotation = quatToEuler(quat.fromValues(val[0], val[1], val[2], val[3])); }\n  public set perspective(val: number) { this._perspective = val; }\n  public set perspectiveOffset(val: number) { this._perspectiveOffset = val; }\n\n  /**\n   * Create new CSSCamera with given element / selector.\n   * @param - The element to apply camera. Can be HTMLElement or CSS selector.\n   */\n  constructor(el: string | HTMLElement) {\n    this._element = getElement(el);\n    this._position = vec3.create();\n    this._scale = vec3.fromValues(1, 1, 1);\n    this._rotation = vec3.create();\n    this._perspective = 0;\n    this._perspectiveOffset = 0;\n    this._updateTimer = -1;\n\n    const element = this._element;\n    const viewport = document.createElement('div');\n    const camera = viewport.cloneNode() as HTMLElement;\n    const world = viewport.cloneNode() as HTMLElement;\n\n    viewport.className = DEFAULT.CLASS.VIEWPORT;\n    camera.className = DEFAULT.CLASS.CAMERA;\n    world.className = DEFAULT.CLASS.WORLD;\n\n    applyCSS(viewport, DEFAULT.STYLE.VIEWPORT);\n    applyCSS(camera, DEFAULT.STYLE.CAMERA);\n    applyCSS(world, DEFAULT.STYLE.WORLD);\n\n    camera.appendChild(world);\n    viewport.appendChild(camera);\n\n    this._viewportEl = viewport;\n    this._cameraEl = camera;\n    this._worldEl = world;\n\n    // EL's PARENT -> VIEWPORT -> CAMERA -> WORLD -> EL\n    element.parentElement!.insertBefore(viewport, element);\n    world.appendChild(element);\n  }\n\n  /**\n   * Focus a camera to given element.\n   * After focus, element will be in front of camera with no rotation applied.\n   * Also, it will have original width / height if neither [scale](#scale) nor [perspectiveOffset](#perspectiveOffset) is applied.\n   * This method won't work if any of element's parent except camera element has scale applied.\n   * @param - The element to focus. Can be HTMLElement or CSS selector.\n   * @return {CSSCamera} The instance itself\n   */\n  public focus(el: string | HTMLElement): this {\n    const element = getElement(el);\n    const focusMatrix = this._getFocusMatrix(element);\n\n    const rotation = quat.create();\n    const translation = vec3.create();\n    mat4.getRotation(rotation, focusMatrix);\n    mat4.getTranslation(translation, focusMatrix);\n\n    const eulerAngle = quatToEuler(rotation);\n\n    vec3.negate(eulerAngle, eulerAngle);\n\n    this._rotation = eulerAngle;\n    this._position = translation;\n    return this;\n  }\n\n  /**\n   * Translate a camera in its local coordinate space.\n   * For example, `camera.translateLocal(0, 0, -300)` will always move camera to direction where it's seeing.\n   * @param - Amount of horizontal translation, in px.\n   * @param - Amount of vertical translation, in px.\n   * @param - Amount of translation in view direction, in px.\n   * @return {CSSCamera} The instance itself\n   */\n  public translateLocal(x: number = 0, y: number = 0, z: number = 0): this {\n    const position = this._position;\n    const rotation = this._rotation;\n\n    const transVec = vec3.fromValues(x, y, z);\n    const rotQuat = quat.create();\n    quat.fromEuler(rotQuat, -rotation[0], -rotation[1], -rotation[2]);\n    vec3.transformQuat(transVec, transVec, rotQuat);\n\n    vec3.add(position, position, transVec);\n    return this;\n  }\n\n  /**\n   * Translate a camera in world(absolute) coordinate space.\n   * @param - Amount of translation in x axis, in px.\n   * @param - Amount of translation in y axis, in px.\n   * @param - Amount of translation in z axis, in px.\n   * @return {CSSCamera} The instance itself\n   */\n  public translate(x: number = 0, y: number = 0, z: number = 0): this {\n    vec3.add(this._position, this._position, vec3.fromValues(x, y, z));\n\n    return this;\n  }\n\n  /**\n   * Rotate a camera in world(absolute) coordinate space.\n   * @param - Amount of rotation in x axis, in degree.\n   * @param - Amount of rotation in y axis, in degree.\n   * @param - Amount of rotation in z axis, in degree.\n   * @return {CSSCamera} The instance itself\n   */\n  public rotate(x: number = 0, y: number = 0, z: number = 0): this {\n    vec3.add(this._rotation, this._rotation, vec3.fromValues(x, y, z));\n\n    return this;\n  }\n\n  /**\n   * Updates a camera CSS with given duration.\n   * Every other camera transforming properties / methods will be batched until this method is called.\n   * @example\n   * const camera = new CSSCamera(el);\n   * console.log(camera.cameraEl.style.transform); // ''\n   *\n   * camera.perspective = 300;\n   * camera.translate(0, 0, 300);\n   * camera.rotate(0, 90, 0);\n   * console.log(camera.cameraEl.style.transform); // '', Not changed!\n   *\n   * await camera.update(1000); // Camera style is updated.\n   * console.log(camera.cameraEl.style.transform); // scale3d(1, 1, 1) translateZ(300px) rotateX(0deg) rotateY(90deg) rotateZ(0deg)\n   * @param - Transition duration in ms.\n   * @param - Transition options.\n   * @return {Promise<CSSCamera>} A promise resolving instance itself\n   */\n  public async update(duration: number = 0, option: Partial<UpdateOption> = {\n    property: 'transform',\n    timingFunction: 'ease-out',\n    delay: '0ms',\n  }): Promise<this> {\n    applyCSS(this._viewportEl, { perspective: `${this.perspective}px` });\n    applyCSS(this._cameraEl, { transform: this.cameraCSS });\n    applyCSS(this._worldEl, { transform: this.worldCSS });\n\n    if (duration > 0) {\n      if (this._updateTimer > 0) {\n        window.clearTimeout(this._updateTimer);\n      }\n\n      const transitionDuration = `${duration}ms`;\n      const updateOption = Object.keys(option).reduce((options: {[key: string]: ValueOf<UpdateOption>}, key) => {\n        options[`transition${key.charAt(0).toUpperCase() + key.slice(1)}`] = option[key as keyof UpdateOption]!;\n        return options;\n      }, {});\n\n      const finalOption = {\n        transitionDuration,\n        ...updateOption,\n      };\n\n      [this._viewportEl, this._cameraEl, this._worldEl].forEach(el => {\n        applyCSS(el, finalOption);\n      });\n    }\n\n    return new Promise(resolve => {\n      // Make sure to use requestAnimationFrame even if duration is 0\n      // To make sure DOM is updated, for successive update() calls.\n      if (duration > 0) {\n        this._updateTimer = window.setTimeout(() => {\n          // Reset transition values\n          [this._viewportEl, this._cameraEl, this._worldEl].forEach(el => {\n            applyCSS(el, { transition: '' });\n          });\n          this._updateTimer = -1;\n          resolve();\n        }, duration);\n      } else {\n        requestAnimationFrame(() => {\n          resolve();\n        });\n      }\n    });\n  }\n\n  private _getFocusMatrix(element: HTMLElement): mat4 {\n    const elements: HTMLElement[] = [];\n    while (element) {\n      elements.push(element);\n      if (element === this._element) break;\n      element = element.parentElement!;\n    }\n\n    // Order by shallow to deep\n    elements.reverse();\n\n    const elStyles = elements.map(el => window.getComputedStyle(el));\n\n    // Find first element that transform-style is not preserve-3d\n    // As all childs of that element is affected by its matrix\n    const firstFlatIndex = findIndex(elStyles, style => style.transformStyle !== 'preserve-3d');\n    if (firstFlatIndex > 0) { // el doesn't have to be preserve-3d'ed\n      elStyles.splice(firstFlatIndex + 1);\n    }\n\n    let parentOffset: Offset = {\n      left: 0,\n      top: 0,\n      width: this.viewportEl.offsetWidth,\n      height: this.viewportEl.offsetHeight,\n    };\n\n    // Accumulated rotation\n    const accRotation = quat.identity(quat.create());\n    // Assume center of screen as (0, 0, 0)\n    const centerPos = vec3.fromValues(0, 0, 0);\n\n    elStyles.forEach((style, idx) => {\n      const el = elements[idx];\n      const currentOffset = {\n        left: el.offsetLeft,\n        top: el.offsetTop,\n        width: el.offsetWidth,\n        height: el.offsetHeight,\n      };\n      const transformMat = getTransformMatrix(style);\n      const offsetFromParent = getOffsetFromParent(currentOffset, parentOffset);\n      vec3.transformQuat(offsetFromParent, offsetFromParent, accRotation);\n\n      vec3.add(centerPos, centerPos, offsetFromParent);\n\n      const rotateOffset = getRotateOffset(style, currentOffset);\n      vec3.transformQuat(rotateOffset, rotateOffset, accRotation);\n\n      const transformOrigin = vec3.clone(centerPos);\n      vec3.add(transformOrigin, transformOrigin, rotateOffset);\n\n      const centerFromOrigin = vec3.create();\n      vec3.sub(centerFromOrigin, centerPos, transformOrigin);\n\n      const invAccRotation = quat.invert(quat.create(), accRotation);\n      vec3.transformQuat(centerFromOrigin, centerFromOrigin, invAccRotation);\n      vec3.transformMat4(centerFromOrigin, centerFromOrigin, transformMat);\n      vec3.transformQuat(centerFromOrigin, centerFromOrigin, accRotation);\n\n      const newCenterPos = vec3.add(vec3.create(), transformOrigin, centerFromOrigin);\n      const rotation = mat4.getRotation(quat.create(), transformMat);\n\n      vec3.copy(centerPos, newCenterPos);\n      quat.mul(accRotation, accRotation, rotation);\n      parentOffset = currentOffset;\n    });\n\n    const perspective = vec3.fromValues(0, 0, this.perspective);\n    vec3.transformQuat(perspective, perspective, accRotation);\n    vec3.add(centerPos, centerPos, perspective);\n\n    const matrix = mat4.create();\n    mat4.fromRotationTranslation(matrix, accRotation, centerPos);\n\n    return matrix;\n  }\n}\n\nexport default CSSCamera;\n"],"names":["getElement","el","baseElement","queryResult","querySelector","document","Error","selector","ELEMENT_NOT_EXIST","nodeName","nodeType","received","MUST_STRING_OR_ELEMENT","applyCSS","element","cssObj","Object","keys","forEach","property","style","quatToEuler","q","rotM","mat4","create","fromQuat","m11","m12","m21","m22","m31","m32","m33","euler","vec3","Math","asin","val","min","max","clamp","abs","atan2","map","rad","PI","radToDeg","VIEWPORT","width","height","overflow","CAMERA","WORLD","_element","_position","_scale","fromValues","_rotation","_perspective","_perspectiveOffset","_updateTimer","this","viewport","createElement","camera","cloneNode","world","className","DEFAULT","appendChild","_viewportEl","_cameraEl","_worldEl","parentElement","insertBefore","CSSCamera","r","quat","fromEuler","perspective","perspectiveOffset","rotation","scale","position","focusMatrix","_getFocusMatrix","translation","getRotation","getTranslation","eulerAngle","negate","x","y","z","transVec","rotQuat","transformQuat","add","duration","option","timingFunction","delay","Promise","transform","cameraCSS","worldCSS","window","clearTimeout","transitionDuration","updateOption","reduce","options","key","charAt","toUpperCase","slice","finalOption_1","resolve","_this","setTimeout","transition","requestAnimationFrame","elements","push","reverse","elStyles","getComputedStyle","firstFlatIndex","iterable","callback","i","length","findIndex","transformStyle","splice","parentOffset","left","top","viewportEl","offsetWidth","offsetHeight","accRotation","identity","centerPos","idx","currentOffset","offsetLeft","offsetTop","transformMat","elStyle","trVal","getPropertyValue","transformStr","exec","matrixVal","split","parseFloat","matrix","getTransformMatrix","offsetFromParent","getOffsetFromParent","rotateOffset","axis","transformOrigin","str","substring","ax","ay","getRotateOffset","clone","centerFromOrigin","sub","invAccRotation","invert","transformMat4","newCenterPos","copy","mul","fromRotationTranslation"],"mappings":"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"}